/* automatically generated by rust-bindgen 0.59.1 */

pub const _BSD_SOURCE: u32 = 1;
pub const _XOPEN_SOURCE: u32 = 700;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __USE_TIME_BITS64: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST64_MAX: i32 = -1;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INTMAX_MIN: i64 = -9223372036854775808;
pub const INTMAX_MAX: u64 = 9223372036854775807;
pub const UINTMAX_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const INTPTR_MIN: i32 = -2147483648;
pub const INTPTR_MAX: u32 = 2147483647;
pub const UINTPTR_MAX: u32 = 4294967295;
pub const PTRDIFF_MIN: i32 = -2147483648;
pub const PTRDIFF_MAX: u32 = 2147483647;
pub const SIZE_MAX: u32 = 4294967295;
pub const AVERROR_EXPERIMENTAL: i32 = -733130664;
pub const AVERROR_INPUT_CHANGED: i32 = -1668179713;
pub const AVERROR_OUTPUT_CHANGED: i32 = -1668179714;
pub const AV_ERROR_MAX_STRING_SIZE: u32 = 64;
extern "C" {
    pub static mut errno: ::std::os::raw::c_int;
}
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
pub type time_t = ::std::os::raw::c_longlong;
pub type suseconds_t = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: usize,
}
impl Default for iovec {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type int_fast8_t = i8;
pub type int_fast64_t = i64;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast64_t = u64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type __wasi_size_t = ::std::os::raw::c_ulong;
#[doc = " Non-negative file size or length of a region within a file."]
pub type __wasi_filesize_t = u64;
#[doc = " Timestamp in nanoseconds."]
pub type __wasi_timestamp_t = u64;
#[doc = " Identifiers for clocks."]
pub type __wasi_clockid_t = u32;
#[doc = " Error codes returned by functions."]
#[doc = " Not all of these error codes are returned by the functions provided by this"]
#[doc = " API; some are used in higher-level library layers, and others are provided"]
#[doc = " merely for alignment with POSIX."]
pub type __wasi_errno_t = u16;
#[doc = " File descriptor rights, determining which actions may be performed."]
pub type __wasi_rights_t = u64;
#[doc = " A file descriptor handle."]
pub type __wasi_fd_t = ::std::os::raw::c_int;
#[doc = " A region of memory for scatter/gather reads."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __wasi_iovec_t {
    #[doc = " The address of the buffer to be filled."]
    pub buf: *mut u8,
    #[doc = " The length of the buffer to be filled."]
    pub buf_len: __wasi_size_t,
}
impl Default for __wasi_iovec_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " A region of memory for scatter/gather writes."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __wasi_ciovec_t {
    #[doc = " The address of the buffer to be written."]
    pub buf: *const u8,
    #[doc = " The length of the buffer to be written."]
    pub buf_len: __wasi_size_t,
}
impl Default for __wasi_ciovec_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Relative offset within a file."]
pub type __wasi_filedelta_t = i64;
#[doc = " The position relative to which to set the offset of the file descriptor."]
pub type __wasi_whence_t = u8;
#[doc = " A reference to the offset of a directory entry."]
#[doc = ""]
#[doc = " The value 0 signifies the start of the directory."]
pub type __wasi_dircookie_t = u64;
#[doc = " The type for the `dirent::d_namlen` field of `dirent` struct."]
pub type __wasi_dirnamlen_t = u32;
#[doc = " File serial number that is unique within its file system."]
pub type __wasi_inode_t = u64;
#[doc = " The type of a file descriptor or file."]
pub type __wasi_filetype_t = u8;
#[doc = " A directory entry."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __wasi_dirent_t {
    #[doc = " The offset of the next directory entry stored in this directory."]
    pub d_next: __wasi_dircookie_t,
    #[doc = " The serial number of the file referred to by this directory entry."]
    pub d_ino: __wasi_inode_t,
    #[doc = " The length of the name of the directory entry."]
    pub d_namlen: __wasi_dirnamlen_t,
    #[doc = " The type of the file referred to by this directory entry."]
    pub d_type: __wasi_filetype_t,
}
#[doc = " File or memory access pattern advisory information."]
pub type __wasi_advice_t = u8;
#[doc = " File descriptor flags."]
pub type __wasi_fdflags_t = u16;
#[doc = " File descriptor attributes."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __wasi_fdstat_t {
    #[doc = " File type."]
    pub fs_filetype: __wasi_filetype_t,
    #[doc = " File descriptor flags."]
    pub fs_flags: __wasi_fdflags_t,
    #[doc = " Rights that apply to this file descriptor."]
    pub fs_rights_base: __wasi_rights_t,
    #[doc = " Maximum set of rights that may be installed on new file descriptors that"]
    #[doc = " are created through this file descriptor, e.g., through `path_open`."]
    pub fs_rights_inheriting: __wasi_rights_t,
}
#[doc = " Identifier for a device containing a file system. Can be used in combination"]
#[doc = " with `inode` to uniquely identify a file or directory in the filesystem."]
pub type __wasi_device_t = u64;
#[doc = " Which file time attributes to adjust."]
pub type __wasi_fstflags_t = u16;
#[doc = " Flags determining the method of how paths are resolved."]
pub type __wasi_lookupflags_t = u32;
#[doc = " Open flags used by `path_open`."]
pub type __wasi_oflags_t = u16;
#[doc = " Number of hard links to an inode."]
pub type __wasi_linkcount_t = u64;
#[doc = " File attributes."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __wasi_filestat_t {
    #[doc = " Device ID of device containing the file."]
    pub dev: __wasi_device_t,
    #[doc = " File serial number."]
    pub ino: __wasi_inode_t,
    #[doc = " File type."]
    pub filetype: __wasi_filetype_t,
    #[doc = " Number of hard links to the file."]
    pub nlink: __wasi_linkcount_t,
    #[doc = " For regular files, the file size in bytes. For symbolic links, the length in bytes of the pathname contained in the symbolic link."]
    pub size: __wasi_filesize_t,
    #[doc = " Last data access timestamp."]
    pub atim: __wasi_timestamp_t,
    #[doc = " Last data modification timestamp."]
    pub mtim: __wasi_timestamp_t,
    #[doc = " Last file status change timestamp."]
    pub ctim: __wasi_timestamp_t,
}
#[doc = " User-provided value that may be attached to objects that is retained when"]
#[doc = " extracted from the implementation."]
pub type __wasi_userdata_t = u64;
#[doc = " Type of a subscription to an event or its occurrence."]
pub type __wasi_eventtype_t = u8;
#[doc = " The state of the file descriptor subscribed to with"]
#[doc = " `eventtype::fd_read` or `eventtype::fd_write`."]
pub type __wasi_eventrwflags_t = u16;
#[doc = " The contents of an `event` when type is `eventtype::fd_read` or"]
#[doc = " `eventtype::fd_write`."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __wasi_event_fd_readwrite_t {
    #[doc = " The number of bytes available for reading or writing."]
    pub nbytes: __wasi_filesize_t,
    #[doc = " The state of the file descriptor."]
    pub flags: __wasi_eventrwflags_t,
}
#[doc = " An event that occurred."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __wasi_event_t {
    #[doc = " User-provided value that got attached to `subscription::userdata`."]
    pub userdata: __wasi_userdata_t,
    #[doc = " If non-zero, an error that occurred while processing the subscription request."]
    pub error: __wasi_errno_t,
    #[doc = " The type of event that occured"]
    pub type_: __wasi_eventtype_t,
    #[doc = " The contents of the event, if it is an `eventtype::fd_read` or"]
    #[doc = " `eventtype::fd_write`. `eventtype::clock` events ignore this field."]
    pub fd_readwrite: __wasi_event_fd_readwrite_t,
}
#[doc = " Flags determining how to interpret the timestamp provided in"]
#[doc = " `subscription_clock::timeout`."]
pub type __wasi_subclockflags_t = u16;
#[doc = " The contents of a `subscription` when type is `eventtype::clock`."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __wasi_subscription_clock_t {
    #[doc = " The clock against which to compare the timestamp."]
    pub id: __wasi_clockid_t,
    #[doc = " The absolute or relative timestamp."]
    pub timeout: __wasi_timestamp_t,
    #[doc = " The amount of time that the implementation may wait additionally"]
    #[doc = " to coalesce with other events."]
    pub precision: __wasi_timestamp_t,
    #[doc = " Flags specifying whether the timeout is absolute or relative"]
    pub flags: __wasi_subclockflags_t,
}
#[doc = " The contents of a `subscription` when type is type is"]
#[doc = " `eventtype::fd_read` or `eventtype::fd_write`."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __wasi_subscription_fd_readwrite_t {
    #[doc = " The file descriptor on which to wait for it to become ready for reading or writing."]
    pub file_descriptor: __wasi_fd_t,
}
#[doc = " The contents of a `subscription`."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union __wasi_subscription_u_u_t {
    pub clock: __wasi_subscription_clock_t,
    pub fd_read: __wasi_subscription_fd_readwrite_t,
    pub fd_write: __wasi_subscription_fd_readwrite_t,
}
impl Default for __wasi_subscription_u_u_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __wasi_subscription_u_t {
    pub tag: u8,
    pub u: __wasi_subscription_u_u_t,
}
impl Default for __wasi_subscription_u_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Subscription to an event."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __wasi_subscription_t {
    #[doc = " User-provided value that is attached to the subscription in the"]
    #[doc = " implementation and returned through `event::userdata`."]
    pub userdata: __wasi_userdata_t,
    #[doc = " The type of the event to which to subscribe, and its contents"]
    pub u: __wasi_subscription_u_t,
}
impl Default for __wasi_subscription_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Exit code generated by a process when exiting."]
pub type __wasi_exitcode_t = u32;
#[doc = " Signal condition."]
pub type __wasi_signal_t = u8;
#[doc = " Flags provided to `sock_recv`."]
pub type __wasi_riflags_t = u16;
#[doc = " Flags returned by `sock_recv`."]
pub type __wasi_roflags_t = u16;
#[doc = " Flags provided to `sock_send`. As there are currently no flags"]
#[doc = " defined, it must be set to zero."]
pub type __wasi_siflags_t = u16;
#[doc = " Which channels on a socket to shut down."]
pub type __wasi_sdflags_t = u8;
#[doc = " Identifiers for preopened capabilities."]
pub type __wasi_preopentype_t = u8;
#[doc = " The contents of a $prestat when type is `preopentype::dir`."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __wasi_prestat_dir_t {
    #[doc = " The length of the directory name for use with `fd_prestat_dir_name`."]
    pub pr_name_len: __wasi_size_t,
}
#[doc = " Information about a pre-opened capability."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union __wasi_prestat_u_t {
    pub dir: __wasi_prestat_dir_t,
}
impl Default for __wasi_prestat_u_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __wasi_prestat_t {
    pub tag: u8,
    pub u: __wasi_prestat_u_t,
}
impl Default for __wasi_prestat_t {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[must_use]
    #[doc = " Read command-line argument data."]
    #[doc = " The size of the array should match that returned by `args_sizes_get`"]
    pub fn __wasi_args_get(argv: *mut *mut u8, argv_buf: *mut u8) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Return command-line argument data sizes."]
    #[doc = " @return"]
    #[doc = " Returns the number of arguments and the size of the argument string"]
    #[doc = " data, or an error."]
    pub fn __wasi_args_sizes_get(
        retptr0: *mut __wasi_size_t,
        retptr1: *mut __wasi_size_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Read environment variable data."]
    #[doc = " The sizes of the buffers should match that returned by `environ_sizes_get`."]
    pub fn __wasi_environ_get(environ: *mut *mut u8, environ_buf: *mut u8) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Return environment variable data sizes."]
    #[doc = " @return"]
    #[doc = " Returns the number of environment variable arguments and the size of the"]
    #[doc = " environment variable data."]
    pub fn __wasi_environ_sizes_get(
        retptr0: *mut __wasi_size_t,
        retptr1: *mut __wasi_size_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Return the resolution of a clock."]
    #[doc = " Implementations are required to provide a non-zero value for supported clocks. For unsupported clocks,"]
    #[doc = " return `errno::inval`."]
    #[doc = " Note: This is similar to `clock_getres` in POSIX."]
    #[doc = " @return"]
    #[doc = " The resolution of the clock, or an error if one happened."]
    pub fn __wasi_clock_res_get(
        id: __wasi_clockid_t,
        retptr0: *mut __wasi_timestamp_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Return the time value of a clock."]
    #[doc = " Note: This is similar to `clock_gettime` in POSIX."]
    #[doc = " @return"]
    #[doc = " The time value of the clock."]
    pub fn __wasi_clock_time_get(
        id: __wasi_clockid_t,
        precision: __wasi_timestamp_t,
        retptr0: *mut __wasi_timestamp_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Provide file advisory information on a file descriptor."]
    #[doc = " Note: This is similar to `posix_fadvise` in POSIX."]
    pub fn __wasi_fd_advise(
        fd: __wasi_fd_t,
        offset: __wasi_filesize_t,
        len: __wasi_filesize_t,
        advice: __wasi_advice_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Force the allocation of space in a file."]
    #[doc = " Note: This is similar to `posix_fallocate` in POSIX."]
    pub fn __wasi_fd_allocate(
        fd: __wasi_fd_t,
        offset: __wasi_filesize_t,
        len: __wasi_filesize_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Close a file descriptor."]
    #[doc = " Note: This is similar to `close` in POSIX."]
    pub fn __wasi_fd_close(fd: __wasi_fd_t) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Synchronize the data of a file to disk."]
    #[doc = " Note: This is similar to `fdatasync` in POSIX."]
    pub fn __wasi_fd_datasync(fd: __wasi_fd_t) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Get the attributes of a file descriptor."]
    #[doc = " Note: This returns similar flags to `fsync(fd, F_GETFL)` in POSIX, as well as additional fields."]
    #[doc = " @return"]
    #[doc = " The buffer where the file descriptor's attributes are stored."]
    pub fn __wasi_fd_fdstat_get(fd: __wasi_fd_t, retptr0: *mut __wasi_fdstat_t) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Adjust the flags associated with a file descriptor."]
    #[doc = " Note: This is similar to `fcntl(fd, F_SETFL, flags)` in POSIX."]
    pub fn __wasi_fd_fdstat_set_flags(fd: __wasi_fd_t, flags: __wasi_fdflags_t) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Adjust the rights associated with a file descriptor."]
    #[doc = " This can only be used to remove rights, and returns `errno::notcapable` if called in a way that would attempt to add rights"]
    pub fn __wasi_fd_fdstat_set_rights(
        fd: __wasi_fd_t,
        fs_rights_base: __wasi_rights_t,
        fs_rights_inheriting: __wasi_rights_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Return the attributes of an open file."]
    #[doc = " @return"]
    #[doc = " The buffer where the file's attributes are stored."]
    pub fn __wasi_fd_filestat_get(
        fd: __wasi_fd_t,
        retptr0: *mut __wasi_filestat_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Adjust the size of an open file. If this increases the file's size, the extra bytes are filled with zeros."]
    #[doc = " Note: This is similar to `ftruncate` in POSIX."]
    pub fn __wasi_fd_filestat_set_size(fd: __wasi_fd_t, size: __wasi_filesize_t) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Adjust the timestamps of an open file or directory."]
    #[doc = " Note: This is similar to `futimens` in POSIX."]
    pub fn __wasi_fd_filestat_set_times(
        fd: __wasi_fd_t,
        atim: __wasi_timestamp_t,
        mtim: __wasi_timestamp_t,
        fst_flags: __wasi_fstflags_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Read from a file descriptor, without using and updating the file descriptor's offset."]
    #[doc = " Note: This is similar to `preadv` in POSIX."]
    #[doc = " @return"]
    #[doc = " The number of bytes read."]
    pub fn __wasi_fd_pread(
        fd: __wasi_fd_t,
        iovs: *const __wasi_iovec_t,
        iovs_len: usize,
        offset: __wasi_filesize_t,
        retptr0: *mut __wasi_size_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Return a description of the given preopened file descriptor."]
    #[doc = " @return"]
    #[doc = " The buffer where the description is stored."]
    pub fn __wasi_fd_prestat_get(fd: __wasi_fd_t, retptr0: *mut __wasi_prestat_t)
        -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Return a description of the given preopened file descriptor."]
    pub fn __wasi_fd_prestat_dir_name(
        fd: __wasi_fd_t,
        path: *mut u8,
        path_len: __wasi_size_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Write to a file descriptor, without using and updating the file descriptor's offset."]
    #[doc = " Note: This is similar to `pwritev` in POSIX."]
    #[doc = " @return"]
    #[doc = " The number of bytes written."]
    pub fn __wasi_fd_pwrite(
        fd: __wasi_fd_t,
        iovs: *const __wasi_ciovec_t,
        iovs_len: usize,
        offset: __wasi_filesize_t,
        retptr0: *mut __wasi_size_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Read from a file descriptor."]
    #[doc = " Note: This is similar to `readv` in POSIX."]
    #[doc = " @return"]
    #[doc = " The number of bytes read."]
    pub fn __wasi_fd_read(
        fd: __wasi_fd_t,
        iovs: *const __wasi_iovec_t,
        iovs_len: usize,
        retptr0: *mut __wasi_size_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Read directory entries from a directory."]
    #[doc = " When successful, the contents of the output buffer consist of a sequence of"]
    #[doc = " directory entries. Each directory entry consists of a `dirent` object,"]
    #[doc = " followed by `dirent::d_namlen` bytes holding the name of the directory"]
    #[doc = " entry."]
    #[doc = " This function fills the output buffer as much as possible, potentially"]
    #[doc = " truncating the last directory entry. This allows the caller to grow its"]
    #[doc = " read buffer size in case it's too small to fit a single large directory"]
    #[doc = " entry, or skip the oversized directory entry."]
    #[doc = " @return"]
    #[doc = " The number of bytes stored in the read buffer. If less than the size of the read buffer, the end of the directory has been reached."]
    pub fn __wasi_fd_readdir(
        fd: __wasi_fd_t,
        buf: *mut u8,
        buf_len: __wasi_size_t,
        cookie: __wasi_dircookie_t,
        retptr0: *mut __wasi_size_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Atomically replace a file descriptor by renumbering another file descriptor."]
    #[doc = " Due to the strong focus on thread safety, this environment does not provide"]
    #[doc = " a mechanism to duplicate or renumber a file descriptor to an arbitrary"]
    #[doc = " number, like `dup2()`. This would be prone to race conditions, as an actual"]
    #[doc = " file descriptor with the same number could be allocated by a different"]
    #[doc = " thread at the same time."]
    #[doc = " This function provides a way to atomically renumber file descriptors, which"]
    #[doc = " would disappear if `dup2()` were to be removed entirely."]
    pub fn __wasi_fd_renumber(fd: __wasi_fd_t, to: __wasi_fd_t) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Move the offset of a file descriptor."]
    #[doc = " Note: This is similar to `lseek` in POSIX."]
    #[doc = " @return"]
    #[doc = " The new offset of the file descriptor, relative to the start of the file."]
    pub fn __wasi_fd_seek(
        fd: __wasi_fd_t,
        offset: __wasi_filedelta_t,
        whence: __wasi_whence_t,
        retptr0: *mut __wasi_filesize_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Synchronize the data and metadata of a file to disk."]
    #[doc = " Note: This is similar to `fsync` in POSIX."]
    pub fn __wasi_fd_sync(fd: __wasi_fd_t) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Return the current offset of a file descriptor."]
    #[doc = " Note: This is similar to `lseek(fd, 0, SEEK_CUR)` in POSIX."]
    #[doc = " @return"]
    #[doc = " The current offset of the file descriptor, relative to the start of the file."]
    pub fn __wasi_fd_tell(fd: __wasi_fd_t, retptr0: *mut __wasi_filesize_t) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Write to a file descriptor."]
    #[doc = " Note: This is similar to `writev` in POSIX."]
    pub fn __wasi_fd_write(
        fd: __wasi_fd_t,
        iovs: *const __wasi_ciovec_t,
        iovs_len: usize,
        retptr0: *mut __wasi_size_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Create a directory."]
    #[doc = " Note: This is similar to `mkdirat` in POSIX."]
    pub fn __wasi_path_create_directory(
        fd: __wasi_fd_t,
        path: *const ::std::os::raw::c_char,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Return the attributes of a file or directory."]
    #[doc = " Note: This is similar to `stat` in POSIX."]
    #[doc = " @return"]
    #[doc = " The buffer where the file's attributes are stored."]
    pub fn __wasi_path_filestat_get(
        fd: __wasi_fd_t,
        flags: __wasi_lookupflags_t,
        path: *const ::std::os::raw::c_char,
        retptr0: *mut __wasi_filestat_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Adjust the timestamps of a file or directory."]
    #[doc = " Note: This is similar to `utimensat` in POSIX."]
    pub fn __wasi_path_filestat_set_times(
        fd: __wasi_fd_t,
        flags: __wasi_lookupflags_t,
        path: *const ::std::os::raw::c_char,
        atim: __wasi_timestamp_t,
        mtim: __wasi_timestamp_t,
        fst_flags: __wasi_fstflags_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Create a hard link."]
    #[doc = " Note: This is similar to `linkat` in POSIX."]
    pub fn __wasi_path_link(
        old_fd: __wasi_fd_t,
        old_flags: __wasi_lookupflags_t,
        old_path: *const ::std::os::raw::c_char,
        new_fd: __wasi_fd_t,
        new_path: *const ::std::os::raw::c_char,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Open a file or directory."]
    #[doc = " The returned file descriptor is not guaranteed to be the lowest-numbered"]
    #[doc = " file descriptor not currently open; it is randomized to prevent"]
    #[doc = " applications from depending on making assumptions about indexes, since this"]
    #[doc = " is error-prone in multi-threaded contexts. The returned file descriptor is"]
    #[doc = " guaranteed to be less than 2**31."]
    #[doc = " Note: This is similar to `openat` in POSIX."]
    #[doc = " @return"]
    #[doc = " The file descriptor of the file that has been opened."]
    pub fn __wasi_path_open(
        fd: __wasi_fd_t,
        dirflags: __wasi_lookupflags_t,
        path: *const ::std::os::raw::c_char,
        oflags: __wasi_oflags_t,
        fs_rights_base: __wasi_rights_t,
        fs_rights_inheriting: __wasi_rights_t,
        fdflags: __wasi_fdflags_t,
        retptr0: *mut __wasi_fd_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Read the contents of a symbolic link."]
    #[doc = " Note: This is similar to `readlinkat` in POSIX."]
    #[doc = " @return"]
    #[doc = " The number of bytes placed in the buffer."]
    pub fn __wasi_path_readlink(
        fd: __wasi_fd_t,
        path: *const ::std::os::raw::c_char,
        buf: *mut u8,
        buf_len: __wasi_size_t,
        retptr0: *mut __wasi_size_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Remove a directory."]
    #[doc = " Return `errno::notempty` if the directory is not empty."]
    #[doc = " Note: This is similar to `unlinkat(fd, path, AT_REMOVEDIR)` in POSIX."]
    pub fn __wasi_path_remove_directory(
        fd: __wasi_fd_t,
        path: *const ::std::os::raw::c_char,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Rename a file or directory."]
    #[doc = " Note: This is similar to `renameat` in POSIX."]
    pub fn __wasi_path_rename(
        fd: __wasi_fd_t,
        old_path: *const ::std::os::raw::c_char,
        new_fd: __wasi_fd_t,
        new_path: *const ::std::os::raw::c_char,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Create a symbolic link."]
    #[doc = " Note: This is similar to `symlinkat` in POSIX."]
    pub fn __wasi_path_symlink(
        old_path: *const ::std::os::raw::c_char,
        fd: __wasi_fd_t,
        new_path: *const ::std::os::raw::c_char,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Unlink a file."]
    #[doc = " Return `errno::isdir` if the path refers to a directory."]
    #[doc = " Note: This is similar to `unlinkat(fd, path, 0)` in POSIX."]
    pub fn __wasi_path_unlink_file(
        fd: __wasi_fd_t,
        path: *const ::std::os::raw::c_char,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Concurrently poll for the occurrence of a set of events."]
    #[doc = " @return"]
    #[doc = " The number of events stored."]
    pub fn __wasi_poll_oneoff(
        in_: *const __wasi_subscription_t,
        out: *mut __wasi_event_t,
        nsubscriptions: __wasi_size_t,
        retptr0: *mut __wasi_size_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[doc = " Terminate the process normally. An exit code of 0 indicates successful"]
    #[doc = " termination of the program. The meanings of other values is dependent on"]
    #[doc = " the environment."]
    pub fn __wasi_proc_exit(rval: __wasi_exitcode_t);
}
extern "C" {
    #[must_use]
    #[doc = " Send a signal to the process of the calling thread."]
    #[doc = " Note: This is similar to `raise` in POSIX."]
    pub fn __wasi_proc_raise(sig: __wasi_signal_t) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Temporarily yield execution of the calling thread."]
    #[doc = " Note: This is similar to `sched_yield` in POSIX."]
    pub fn __wasi_sched_yield() -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Write high-quality random data into a buffer."]
    #[doc = " This function blocks when the implementation is unable to immediately"]
    #[doc = " provide sufficient high-quality random data."]
    #[doc = " This function may execute slowly, so when large mounts of random data are"]
    #[doc = " required, it's advisable to use this function to seed a pseudo-random"]
    #[doc = " number generator, rather than to provide the random data directly."]
    pub fn __wasi_random_get(buf: *mut u8, buf_len: __wasi_size_t) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Receive a message from a socket."]
    #[doc = " Note: This is similar to `recv` in POSIX, though it also supports reading"]
    #[doc = " the data into multiple buffers in the manner of `readv`."]
    #[doc = " @return"]
    #[doc = " Number of bytes stored in ri_data and message flags."]
    pub fn __wasi_sock_recv(
        fd: __wasi_fd_t,
        ri_data: *const __wasi_iovec_t,
        ri_data_len: usize,
        ri_flags: __wasi_riflags_t,
        retptr0: *mut __wasi_size_t,
        retptr1: *mut __wasi_roflags_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Send a message on a socket."]
    #[doc = " Note: This is similar to `send` in POSIX, though it also supports writing"]
    #[doc = " the data from multiple buffers in the manner of `writev`."]
    #[doc = " @return"]
    #[doc = " Number of bytes transmitted."]
    pub fn __wasi_sock_send(
        fd: __wasi_fd_t,
        si_data: *const __wasi_ciovec_t,
        si_data_len: usize,
        si_flags: __wasi_siflags_t,
        retptr0: *mut __wasi_size_t,
    ) -> __wasi_errno_t;
}
extern "C" {
    #[must_use]
    #[doc = " Shut down socket send and receive channels."]
    #[doc = " Note: This is similar to `shutdown` in POSIX."]
    pub fn __wasi_sock_shutdown(fd: __wasi_fd_t, how: __wasi_sdflags_t) -> __wasi_errno_t;
}
extern "C" {
    #[doc = " Put a description of the AVERROR code errnum in errbuf."]
    #[doc = " In case of failure the global variable errno is set to indicate the"]
    #[doc = " error. Even in case of failure av_strerror() will print a generic"]
    #[doc = " error message indicating the errnum provided to errbuf."]
    #[doc = ""]
    #[doc = " @param errnum      error code to describe"]
    #[doc = " @param errbuf      buffer to which description is written"]
    #[doc = " @param errbuf_size the size in bytes of errbuf"]
    #[doc = " @return 0 on success, a negative value if a description for errnum"]
    #[doc = " cannot be found"]
    pub fn av_strerror(
        errnum: ::std::os::raw::c_int,
        errbuf: *mut ::std::os::raw::c_char,
        errbuf_size: usize,
    ) -> ::std::os::raw::c_int;
}
