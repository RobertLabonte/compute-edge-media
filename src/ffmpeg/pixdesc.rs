/* automatically generated by rust-bindgen 0.59.1 */

pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __USE_TIME_BITS64: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST64_MAX: i32 = -1;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INTMAX_MIN: i64 = -9223372036854775808;
pub const INTMAX_MAX: u64 = 9223372036854775807;
pub const UINTMAX_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const INTPTR_MIN: i32 = -2147483648;
pub const INTPTR_MAX: u32 = 2147483647;
pub const UINTPTR_MAX: u32 = 4294967295;
pub const PTRDIFF_MIN: i32 = -2147483648;
pub const PTRDIFF_MAX: u32 = 2147483647;
pub const SIZE_MAX: u32 = 4294967295;
pub const AV_HAVE_BIGENDIAN: u32 = 0;
pub const AV_HAVE_FAST_UNALIGNED: u32 = 0;
pub const LIBAVUTIL_VERSION_MAJOR: u32 = 57;
pub const LIBAVUTIL_VERSION_MINOR: u32 = 0;
pub const LIBAVUTIL_VERSION_MICRO: u32 = 100;
pub const AVPALETTE_SIZE: u32 = 1024;
pub const AVPALETTE_COUNT: u32 = 256;
pub const AV_PIX_FMT_FLAG_BE: u32 = 1;
pub const AV_PIX_FMT_FLAG_PAL: u32 = 2;
pub const AV_PIX_FMT_FLAG_BITSTREAM: u32 = 4;
pub const AV_PIX_FMT_FLAG_HWACCEL: u32 = 8;
pub const AV_PIX_FMT_FLAG_PLANAR: u32 = 16;
pub const AV_PIX_FMT_FLAG_RGB: u32 = 32;
pub const AV_PIX_FMT_FLAG_ALPHA: u32 = 128;
pub const AV_PIX_FMT_FLAG_BAYER: u32 = 256;
pub const AV_PIX_FMT_FLAG_FLOAT: u32 = 512;
pub const FF_LOSS_RESOLUTION: u32 = 1;
pub const FF_LOSS_DEPTH: u32 = 2;
pub const FF_LOSS_COLORSPACE: u32 = 4;
pub const FF_LOSS_ALPHA: u32 = 8;
pub const FF_LOSS_COLORQUANT: u32 = 16;
pub const FF_LOSS_CHROMA: u32 = 32;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
pub type time_t = ::std::os::raw::c_longlong;
pub type suseconds_t = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct iovec {
    pub iov_base: *mut ::std::os::raw::c_void,
    pub iov_len: usize,
}
impl Default for iovec {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type int_fast8_t = i8;
pub type int_fast64_t = i64;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast64_t = u64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
extern "C" {
    pub fn imaxabs(arg1: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(arg1: intmax_t, arg2: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        arg1: *const ::std::os::raw::c_char,
        arg2: *mut *mut ::std::os::raw::c_char,
        arg3: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        arg1: *const wchar_t,
        arg2: *mut *mut wchar_t,
        arg3: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        arg1: *const wchar_t,
        arg2: *mut *mut wchar_t,
        arg3: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
pub const AVPixelFormat_AV_PIX_FMT_NONE: AVPixelFormat = -1;
#[doc = "< planar YUV 4:2:0, 12bpp, (1 Cr & Cb sample per 2x2 Y samples)"]
pub const AVPixelFormat_AV_PIX_FMT_YUV420P: AVPixelFormat = 0;
#[doc = "< packed YUV 4:2:2, 16bpp, Y0 Cb Y1 Cr"]
pub const AVPixelFormat_AV_PIX_FMT_YUYV422: AVPixelFormat = 1;
#[doc = "< packed RGB 8:8:8, 24bpp, RGBRGB..."]
pub const AVPixelFormat_AV_PIX_FMT_RGB24: AVPixelFormat = 2;
#[doc = "< packed RGB 8:8:8, 24bpp, BGRBGR..."]
pub const AVPixelFormat_AV_PIX_FMT_BGR24: AVPixelFormat = 3;
#[doc = "< planar YUV 4:2:2, 16bpp, (1 Cr & Cb sample per 2x1 Y samples)"]
pub const AVPixelFormat_AV_PIX_FMT_YUV422P: AVPixelFormat = 4;
#[doc = "< planar YUV 4:4:4, 24bpp, (1 Cr & Cb sample per 1x1 Y samples)"]
pub const AVPixelFormat_AV_PIX_FMT_YUV444P: AVPixelFormat = 5;
#[doc = "< planar YUV 4:1:0,  9bpp, (1 Cr & Cb sample per 4x4 Y samples)"]
pub const AVPixelFormat_AV_PIX_FMT_YUV410P: AVPixelFormat = 6;
#[doc = "< planar YUV 4:1:1, 12bpp, (1 Cr & Cb sample per 4x1 Y samples)"]
pub const AVPixelFormat_AV_PIX_FMT_YUV411P: AVPixelFormat = 7;
#[doc = "<        Y        ,  8bpp"]
pub const AVPixelFormat_AV_PIX_FMT_GRAY8: AVPixelFormat = 8;
#[doc = "<        Y        ,  1bpp, 0 is white, 1 is black, in each byte pixels are ordered from the msb to the lsb"]
pub const AVPixelFormat_AV_PIX_FMT_MONOWHITE: AVPixelFormat = 9;
#[doc = "<        Y        ,  1bpp, 0 is black, 1 is white, in each byte pixels are ordered from the msb to the lsb"]
pub const AVPixelFormat_AV_PIX_FMT_MONOBLACK: AVPixelFormat = 10;
#[doc = "< 8 bits with AV_PIX_FMT_RGB32 palette"]
pub const AVPixelFormat_AV_PIX_FMT_PAL8: AVPixelFormat = 11;
#[doc = "< planar YUV 4:2:0, 12bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV420P and setting color_range"]
pub const AVPixelFormat_AV_PIX_FMT_YUVJ420P: AVPixelFormat = 12;
#[doc = "< planar YUV 4:2:2, 16bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV422P and setting color_range"]
pub const AVPixelFormat_AV_PIX_FMT_YUVJ422P: AVPixelFormat = 13;
#[doc = "< planar YUV 4:4:4, 24bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV444P and setting color_range"]
pub const AVPixelFormat_AV_PIX_FMT_YUVJ444P: AVPixelFormat = 14;
#[doc = "< packed YUV 4:2:2, 16bpp, Cb Y0 Cr Y1"]
pub const AVPixelFormat_AV_PIX_FMT_UYVY422: AVPixelFormat = 15;
#[doc = "< packed YUV 4:1:1, 12bpp, Cb Y0 Y1 Cr Y2 Y3"]
pub const AVPixelFormat_AV_PIX_FMT_UYYVYY411: AVPixelFormat = 16;
#[doc = "< packed RGB 3:3:2,  8bpp, (msb)2B 3G 3R(lsb)"]
pub const AVPixelFormat_AV_PIX_FMT_BGR8: AVPixelFormat = 17;
#[doc = "< packed RGB 1:2:1 bitstream,  4bpp, (msb)1B 2G 1R(lsb), a byte contains two pixels, the first pixel in the byte is the one composed by the 4 msb bits"]
pub const AVPixelFormat_AV_PIX_FMT_BGR4: AVPixelFormat = 18;
#[doc = "< packed RGB 1:2:1,  8bpp, (msb)1B 2G 1R(lsb)"]
pub const AVPixelFormat_AV_PIX_FMT_BGR4_BYTE: AVPixelFormat = 19;
#[doc = "< packed RGB 3:3:2,  8bpp, (msb)2R 3G 3B(lsb)"]
pub const AVPixelFormat_AV_PIX_FMT_RGB8: AVPixelFormat = 20;
#[doc = "< packed RGB 1:2:1 bitstream,  4bpp, (msb)1R 2G 1B(lsb), a byte contains two pixels, the first pixel in the byte is the one composed by the 4 msb bits"]
pub const AVPixelFormat_AV_PIX_FMT_RGB4: AVPixelFormat = 21;
#[doc = "< packed RGB 1:2:1,  8bpp, (msb)1R 2G 1B(lsb)"]
pub const AVPixelFormat_AV_PIX_FMT_RGB4_BYTE: AVPixelFormat = 22;
#[doc = "< planar YUV 4:2:0, 12bpp, 1 plane for Y and 1 plane for the UV components, which are interleaved (first byte U and the following byte V)"]
pub const AVPixelFormat_AV_PIX_FMT_NV12: AVPixelFormat = 23;
#[doc = "< as above, but U and V bytes are swapped"]
pub const AVPixelFormat_AV_PIX_FMT_NV21: AVPixelFormat = 24;
#[doc = "< packed ARGB 8:8:8:8, 32bpp, ARGBARGB..."]
pub const AVPixelFormat_AV_PIX_FMT_ARGB: AVPixelFormat = 25;
#[doc = "< packed RGBA 8:8:8:8, 32bpp, RGBARGBA..."]
pub const AVPixelFormat_AV_PIX_FMT_RGBA: AVPixelFormat = 26;
#[doc = "< packed ABGR 8:8:8:8, 32bpp, ABGRABGR..."]
pub const AVPixelFormat_AV_PIX_FMT_ABGR: AVPixelFormat = 27;
#[doc = "< packed BGRA 8:8:8:8, 32bpp, BGRABGRA..."]
pub const AVPixelFormat_AV_PIX_FMT_BGRA: AVPixelFormat = 28;
#[doc = "<        Y        , 16bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GRAY16BE: AVPixelFormat = 29;
#[doc = "<        Y        , 16bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GRAY16LE: AVPixelFormat = 30;
#[doc = "< planar YUV 4:4:0 (1 Cr & Cb sample per 1x2 Y samples)"]
pub const AVPixelFormat_AV_PIX_FMT_YUV440P: AVPixelFormat = 31;
#[doc = "< planar YUV 4:4:0 full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV440P and setting color_range"]
pub const AVPixelFormat_AV_PIX_FMT_YUVJ440P: AVPixelFormat = 32;
#[doc = "< planar YUV 4:2:0, 20bpp, (1 Cr & Cb sample per 2x2 Y & A samples)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P: AVPixelFormat = 33;
#[doc = "< packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the 2-byte value for each R/G/B component is stored as big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_RGB48BE: AVPixelFormat = 34;
#[doc = "< packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the 2-byte value for each R/G/B component is stored as little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_RGB48LE: AVPixelFormat = 35;
#[doc = "< packed RGB 5:6:5, 16bpp, (msb)   5R 6G 5B(lsb), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_RGB565BE: AVPixelFormat = 36;
#[doc = "< packed RGB 5:6:5, 16bpp, (msb)   5R 6G 5B(lsb), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_RGB565LE: AVPixelFormat = 37;
#[doc = "< packed RGB 5:5:5, 16bpp, (msb)1X 5R 5G 5B(lsb), big-endian   , X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_RGB555BE: AVPixelFormat = 38;
#[doc = "< packed RGB 5:5:5, 16bpp, (msb)1X 5R 5G 5B(lsb), little-endian, X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_RGB555LE: AVPixelFormat = 39;
#[doc = "< packed BGR 5:6:5, 16bpp, (msb)   5B 6G 5R(lsb), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BGR565BE: AVPixelFormat = 40;
#[doc = "< packed BGR 5:6:5, 16bpp, (msb)   5B 6G 5R(lsb), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BGR565LE: AVPixelFormat = 41;
#[doc = "< packed BGR 5:5:5, 16bpp, (msb)1X 5B 5G 5R(lsb), big-endian   , X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_BGR555BE: AVPixelFormat = 42;
#[doc = "< packed BGR 5:5:5, 16bpp, (msb)1X 5B 5G 5R(lsb), little-endian, X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_BGR555LE: AVPixelFormat = 43;
#[doc = "  Hardware acceleration through VA-API, data[3] contains a"]
#[doc = "  VASurfaceID."]
pub const AVPixelFormat_AV_PIX_FMT_VAAPI: AVPixelFormat = 44;
#[doc = "< planar YUV 4:2:0, 24bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV420P16LE: AVPixelFormat = 45;
#[doc = "< planar YUV 4:2:0, 24bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV420P16BE: AVPixelFormat = 46;
#[doc = "< planar YUV 4:2:2, 32bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV422P16LE: AVPixelFormat = 47;
#[doc = "< planar YUV 4:2:2, 32bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV422P16BE: AVPixelFormat = 48;
#[doc = "< planar YUV 4:4:4, 48bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV444P16LE: AVPixelFormat = 49;
#[doc = "< planar YUV 4:4:4, 48bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV444P16BE: AVPixelFormat = 50;
#[doc = "< HW decoding through DXVA2, Picture.data[3] contains a LPDIRECT3DSURFACE9 pointer"]
pub const AVPixelFormat_AV_PIX_FMT_DXVA2_VLD: AVPixelFormat = 51;
#[doc = "< packed RGB 4:4:4, 16bpp, (msb)4X 4R 4G 4B(lsb), little-endian, X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_RGB444LE: AVPixelFormat = 52;
#[doc = "< packed RGB 4:4:4, 16bpp, (msb)4X 4R 4G 4B(lsb), big-endian,    X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_RGB444BE: AVPixelFormat = 53;
#[doc = "< packed BGR 4:4:4, 16bpp, (msb)4X 4B 4G 4R(lsb), little-endian, X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_BGR444LE: AVPixelFormat = 54;
#[doc = "< packed BGR 4:4:4, 16bpp, (msb)4X 4B 4G 4R(lsb), big-endian,    X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_BGR444BE: AVPixelFormat = 55;
#[doc = "< 8 bits gray, 8 bits alpha"]
pub const AVPixelFormat_AV_PIX_FMT_YA8: AVPixelFormat = 56;
#[doc = "< alias for AV_PIX_FMT_YA8"]
pub const AVPixelFormat_AV_PIX_FMT_Y400A: AVPixelFormat = 56;
#[doc = "< alias for AV_PIX_FMT_YA8"]
pub const AVPixelFormat_AV_PIX_FMT_GRAY8A: AVPixelFormat = 56;
#[doc = "< packed RGB 16:16:16, 48bpp, 16B, 16G, 16R, the 2-byte value for each R/G/B component is stored as big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BGR48BE: AVPixelFormat = 57;
#[doc = "< packed RGB 16:16:16, 48bpp, 16B, 16G, 16R, the 2-byte value for each R/G/B component is stored as little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BGR48LE: AVPixelFormat = 58;
#[doc = "< planar YUV 4:2:0, 13.5bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV420P9BE: AVPixelFormat = 59;
#[doc = "< planar YUV 4:2:0, 13.5bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV420P9LE: AVPixelFormat = 60;
#[doc = "< planar YUV 4:2:0, 15bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV420P10BE: AVPixelFormat = 61;
#[doc = "< planar YUV 4:2:0, 15bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV420P10LE: AVPixelFormat = 62;
#[doc = "< planar YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV422P10BE: AVPixelFormat = 63;
#[doc = "< planar YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV422P10LE: AVPixelFormat = 64;
#[doc = "< planar YUV 4:4:4, 27bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV444P9BE: AVPixelFormat = 65;
#[doc = "< planar YUV 4:4:4, 27bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV444P9LE: AVPixelFormat = 66;
#[doc = "< planar YUV 4:4:4, 30bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV444P10BE: AVPixelFormat = 67;
#[doc = "< planar YUV 4:4:4, 30bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV444P10LE: AVPixelFormat = 68;
#[doc = "< planar YUV 4:2:2, 18bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV422P9BE: AVPixelFormat = 69;
#[doc = "< planar YUV 4:2:2, 18bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV422P9LE: AVPixelFormat = 70;
#[doc = "< planar GBR 4:4:4 24bpp"]
pub const AVPixelFormat_AV_PIX_FMT_GBRP: AVPixelFormat = 71;
pub const AVPixelFormat_AV_PIX_FMT_GBR24P: AVPixelFormat = 71;
#[doc = "< planar GBR 4:4:4 27bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRP9BE: AVPixelFormat = 72;
#[doc = "< planar GBR 4:4:4 27bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRP9LE: AVPixelFormat = 73;
#[doc = "< planar GBR 4:4:4 30bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRP10BE: AVPixelFormat = 74;
#[doc = "< planar GBR 4:4:4 30bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRP10LE: AVPixelFormat = 75;
#[doc = "< planar GBR 4:4:4 48bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRP16BE: AVPixelFormat = 76;
#[doc = "< planar GBR 4:4:4 48bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRP16LE: AVPixelFormat = 77;
#[doc = "< planar YUV 4:2:2 24bpp, (1 Cr & Cb sample per 2x1 Y & A samples)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P: AVPixelFormat = 78;
#[doc = "< planar YUV 4:4:4 32bpp, (1 Cr & Cb sample per 1x1 Y & A samples)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P: AVPixelFormat = 79;
#[doc = "< planar YUV 4:2:0 22.5bpp, (1 Cr & Cb sample per 2x2 Y & A samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P9BE: AVPixelFormat = 80;
#[doc = "< planar YUV 4:2:0 22.5bpp, (1 Cr & Cb sample per 2x2 Y & A samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P9LE: AVPixelFormat = 81;
#[doc = "< planar YUV 4:2:2 27bpp, (1 Cr & Cb sample per 2x1 Y & A samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P9BE: AVPixelFormat = 82;
#[doc = "< planar YUV 4:2:2 27bpp, (1 Cr & Cb sample per 2x1 Y & A samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P9LE: AVPixelFormat = 83;
#[doc = "< planar YUV 4:4:4 36bpp, (1 Cr & Cb sample per 1x1 Y & A samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P9BE: AVPixelFormat = 84;
#[doc = "< planar YUV 4:4:4 36bpp, (1 Cr & Cb sample per 1x1 Y & A samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P9LE: AVPixelFormat = 85;
#[doc = "< planar YUV 4:2:0 25bpp, (1 Cr & Cb sample per 2x2 Y & A samples, big-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P10BE: AVPixelFormat = 86;
#[doc = "< planar YUV 4:2:0 25bpp, (1 Cr & Cb sample per 2x2 Y & A samples, little-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P10LE: AVPixelFormat = 87;
#[doc = "< planar YUV 4:2:2 30bpp, (1 Cr & Cb sample per 2x1 Y & A samples, big-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P10BE: AVPixelFormat = 88;
#[doc = "< planar YUV 4:2:2 30bpp, (1 Cr & Cb sample per 2x1 Y & A samples, little-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P10LE: AVPixelFormat = 89;
#[doc = "< planar YUV 4:4:4 40bpp, (1 Cr & Cb sample per 1x1 Y & A samples, big-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P10BE: AVPixelFormat = 90;
#[doc = "< planar YUV 4:4:4 40bpp, (1 Cr & Cb sample per 1x1 Y & A samples, little-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P10LE: AVPixelFormat = 91;
#[doc = "< planar YUV 4:2:0 40bpp, (1 Cr & Cb sample per 2x2 Y & A samples, big-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P16BE: AVPixelFormat = 92;
#[doc = "< planar YUV 4:2:0 40bpp, (1 Cr & Cb sample per 2x2 Y & A samples, little-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA420P16LE: AVPixelFormat = 93;
#[doc = "< planar YUV 4:2:2 48bpp, (1 Cr & Cb sample per 2x1 Y & A samples, big-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P16BE: AVPixelFormat = 94;
#[doc = "< planar YUV 4:2:2 48bpp, (1 Cr & Cb sample per 2x1 Y & A samples, little-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P16LE: AVPixelFormat = 95;
#[doc = "< planar YUV 4:4:4 64bpp, (1 Cr & Cb sample per 1x1 Y & A samples, big-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P16BE: AVPixelFormat = 96;
#[doc = "< planar YUV 4:4:4 64bpp, (1 Cr & Cb sample per 1x1 Y & A samples, little-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P16LE: AVPixelFormat = 97;
#[doc = "< HW acceleration through VDPAU, Picture.data[3] contains a VdpVideoSurface"]
pub const AVPixelFormat_AV_PIX_FMT_VDPAU: AVPixelFormat = 98;
#[doc = "< packed XYZ 4:4:4, 36 bpp, (msb) 12X, 12Y, 12Z (lsb), the 2-byte value for each X/Y/Z is stored as little-endian, the 4 lower bits are set to 0"]
pub const AVPixelFormat_AV_PIX_FMT_XYZ12LE: AVPixelFormat = 99;
#[doc = "< packed XYZ 4:4:4, 36 bpp, (msb) 12X, 12Y, 12Z (lsb), the 2-byte value for each X/Y/Z is stored as big-endian, the 4 lower bits are set to 0"]
pub const AVPixelFormat_AV_PIX_FMT_XYZ12BE: AVPixelFormat = 100;
#[doc = "< interleaved chroma YUV 4:2:2, 16bpp, (1 Cr & Cb sample per 2x1 Y samples)"]
pub const AVPixelFormat_AV_PIX_FMT_NV16: AVPixelFormat = 101;
#[doc = "< interleaved chroma YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_NV20LE: AVPixelFormat = 102;
#[doc = "< interleaved chroma YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_NV20BE: AVPixelFormat = 103;
#[doc = "< packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A, the 2-byte value for each R/G/B/A component is stored as big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_RGBA64BE: AVPixelFormat = 104;
#[doc = "< packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A, the 2-byte value for each R/G/B/A component is stored as little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_RGBA64LE: AVPixelFormat = 105;
#[doc = "< packed RGBA 16:16:16:16, 64bpp, 16B, 16G, 16R, 16A, the 2-byte value for each R/G/B/A component is stored as big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BGRA64BE: AVPixelFormat = 106;
#[doc = "< packed RGBA 16:16:16:16, 64bpp, 16B, 16G, 16R, 16A, the 2-byte value for each R/G/B/A component is stored as little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BGRA64LE: AVPixelFormat = 107;
#[doc = "< packed YUV 4:2:2, 16bpp, Y0 Cr Y1 Cb"]
pub const AVPixelFormat_AV_PIX_FMT_YVYU422: AVPixelFormat = 108;
#[doc = "< 16 bits gray, 16 bits alpha (big-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YA16BE: AVPixelFormat = 109;
#[doc = "< 16 bits gray, 16 bits alpha (little-endian)"]
pub const AVPixelFormat_AV_PIX_FMT_YA16LE: AVPixelFormat = 110;
#[doc = "< planar GBRA 4:4:4:4 32bpp"]
pub const AVPixelFormat_AV_PIX_FMT_GBRAP: AVPixelFormat = 111;
#[doc = "< planar GBRA 4:4:4:4 64bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRAP16BE: AVPixelFormat = 112;
#[doc = "< planar GBRA 4:4:4:4 64bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRAP16LE: AVPixelFormat = 113;
#[doc = "  HW acceleration through QSV, data[3] contains a pointer to the"]
#[doc = "  mfxFrameSurface1 structure."]
pub const AVPixelFormat_AV_PIX_FMT_QSV: AVPixelFormat = 114;
#[doc = " HW acceleration though MMAL, data[3] contains a pointer to the"]
#[doc = " MMAL_BUFFER_HEADER_T structure."]
pub const AVPixelFormat_AV_PIX_FMT_MMAL: AVPixelFormat = 115;
#[doc = "< HW decoding through Direct3D11 via old API, Picture.data[3] contains a ID3D11VideoDecoderOutputView pointer"]
pub const AVPixelFormat_AV_PIX_FMT_D3D11VA_VLD: AVPixelFormat = 116;
#[doc = " HW acceleration through CUDA. data[i] contain CUdeviceptr pointers"]
#[doc = " exactly as for system memory frames."]
pub const AVPixelFormat_AV_PIX_FMT_CUDA: AVPixelFormat = 117;
#[doc = "< packed RGB 8:8:8, 32bpp, XRGBXRGB...   X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_0RGB: AVPixelFormat = 118;
#[doc = "< packed RGB 8:8:8, 32bpp, RGBXRGBX...   X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_RGB0: AVPixelFormat = 119;
#[doc = "< packed BGR 8:8:8, 32bpp, XBGRXBGR...   X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_0BGR: AVPixelFormat = 120;
#[doc = "< packed BGR 8:8:8, 32bpp, BGRXBGRX...   X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_BGR0: AVPixelFormat = 121;
#[doc = "< planar YUV 4:2:0,18bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV420P12BE: AVPixelFormat = 122;
#[doc = "< planar YUV 4:2:0,18bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV420P12LE: AVPixelFormat = 123;
#[doc = "< planar YUV 4:2:0,21bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV420P14BE: AVPixelFormat = 124;
#[doc = "< planar YUV 4:2:0,21bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV420P14LE: AVPixelFormat = 125;
#[doc = "< planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV422P12BE: AVPixelFormat = 126;
#[doc = "< planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV422P12LE: AVPixelFormat = 127;
#[doc = "< planar YUV 4:2:2,28bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV422P14BE: AVPixelFormat = 128;
#[doc = "< planar YUV 4:2:2,28bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV422P14LE: AVPixelFormat = 129;
#[doc = "< planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV444P12BE: AVPixelFormat = 130;
#[doc = "< planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV444P12LE: AVPixelFormat = 131;
#[doc = "< planar YUV 4:4:4,42bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV444P14BE: AVPixelFormat = 132;
#[doc = "< planar YUV 4:4:4,42bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV444P14LE: AVPixelFormat = 133;
#[doc = "< planar GBR 4:4:4 36bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRP12BE: AVPixelFormat = 134;
#[doc = "< planar GBR 4:4:4 36bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRP12LE: AVPixelFormat = 135;
#[doc = "< planar GBR 4:4:4 42bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRP14BE: AVPixelFormat = 136;
#[doc = "< planar GBR 4:4:4 42bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRP14LE: AVPixelFormat = 137;
#[doc = "< planar YUV 4:1:1, 12bpp, (1 Cr & Cb sample per 4x1 Y samples) full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV411P and setting color_range"]
pub const AVPixelFormat_AV_PIX_FMT_YUVJ411P: AVPixelFormat = 138;
#[doc = "< bayer, BGBG..(odd line), GRGR..(even line), 8-bit samples"]
pub const AVPixelFormat_AV_PIX_FMT_BAYER_BGGR8: AVPixelFormat = 139;
#[doc = "< bayer, RGRG..(odd line), GBGB..(even line), 8-bit samples"]
pub const AVPixelFormat_AV_PIX_FMT_BAYER_RGGB8: AVPixelFormat = 140;
#[doc = "< bayer, GBGB..(odd line), RGRG..(even line), 8-bit samples"]
pub const AVPixelFormat_AV_PIX_FMT_BAYER_GBRG8: AVPixelFormat = 141;
#[doc = "< bayer, GRGR..(odd line), BGBG..(even line), 8-bit samples"]
pub const AVPixelFormat_AV_PIX_FMT_BAYER_GRBG8: AVPixelFormat = 142;
#[doc = "< bayer, BGBG..(odd line), GRGR..(even line), 16-bit samples, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BAYER_BGGR16LE: AVPixelFormat = 143;
#[doc = "< bayer, BGBG..(odd line), GRGR..(even line), 16-bit samples, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BAYER_BGGR16BE: AVPixelFormat = 144;
#[doc = "< bayer, RGRG..(odd line), GBGB..(even line), 16-bit samples, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BAYER_RGGB16LE: AVPixelFormat = 145;
#[doc = "< bayer, RGRG..(odd line), GBGB..(even line), 16-bit samples, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BAYER_RGGB16BE: AVPixelFormat = 146;
#[doc = "< bayer, GBGB..(odd line), RGRG..(even line), 16-bit samples, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BAYER_GBRG16LE: AVPixelFormat = 147;
#[doc = "< bayer, GBGB..(odd line), RGRG..(even line), 16-bit samples, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BAYER_GBRG16BE: AVPixelFormat = 148;
#[doc = "< bayer, GRGR..(odd line), BGBG..(even line), 16-bit samples, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BAYER_GRBG16LE: AVPixelFormat = 149;
#[doc = "< bayer, GRGR..(odd line), BGBG..(even line), 16-bit samples, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_BAYER_GRBG16BE: AVPixelFormat = 150;
#[doc = "< XVideo Motion Acceleration via common packet passing"]
pub const AVPixelFormat_AV_PIX_FMT_XVMC: AVPixelFormat = 151;
#[doc = "< planar YUV 4:4:0,20bpp, (1 Cr & Cb sample per 1x2 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV440P10LE: AVPixelFormat = 152;
#[doc = "< planar YUV 4:4:0,20bpp, (1 Cr & Cb sample per 1x2 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV440P10BE: AVPixelFormat = 153;
#[doc = "< planar YUV 4:4:0,24bpp, (1 Cr & Cb sample per 1x2 Y samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV440P12LE: AVPixelFormat = 154;
#[doc = "< planar YUV 4:4:0,24bpp, (1 Cr & Cb sample per 1x2 Y samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUV440P12BE: AVPixelFormat = 155;
#[doc = "< packed AYUV 4:4:4,64bpp (1 Cr & Cb sample per 1x1 Y & A samples), little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_AYUV64LE: AVPixelFormat = 156;
#[doc = "< packed AYUV 4:4:4,64bpp (1 Cr & Cb sample per 1x1 Y & A samples), big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_AYUV64BE: AVPixelFormat = 157;
#[doc = "< hardware decoding through Videotoolbox"]
pub const AVPixelFormat_AV_PIX_FMT_VIDEOTOOLBOX: AVPixelFormat = 158;
#[doc = "< like NV12, with 10bpp per component, data in the high bits, zeros in the low bits, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_P010LE: AVPixelFormat = 159;
#[doc = "< like NV12, with 10bpp per component, data in the high bits, zeros in the low bits, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_P010BE: AVPixelFormat = 160;
#[doc = "< planar GBR 4:4:4:4 48bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRAP12BE: AVPixelFormat = 161;
#[doc = "< planar GBR 4:4:4:4 48bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRAP12LE: AVPixelFormat = 162;
#[doc = "< planar GBR 4:4:4:4 40bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRAP10BE: AVPixelFormat = 163;
#[doc = "< planar GBR 4:4:4:4 40bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRAP10LE: AVPixelFormat = 164;
#[doc = "< hardware decoding through MediaCodec"]
pub const AVPixelFormat_AV_PIX_FMT_MEDIACODEC: AVPixelFormat = 165;
#[doc = "<        Y        , 12bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GRAY12BE: AVPixelFormat = 166;
#[doc = "<        Y        , 12bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GRAY12LE: AVPixelFormat = 167;
#[doc = "<        Y        , 10bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GRAY10BE: AVPixelFormat = 168;
#[doc = "<        Y        , 10bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GRAY10LE: AVPixelFormat = 169;
#[doc = "< like NV12, with 16bpp per component, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_P016LE: AVPixelFormat = 170;
#[doc = "< like NV12, with 16bpp per component, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_P016BE: AVPixelFormat = 171;
#[doc = " Hardware surfaces for Direct3D11."]
#[doc = ""]
#[doc = " This is preferred over the legacy AV_PIX_FMT_D3D11VA_VLD. The new D3D11"]
#[doc = " hwaccel API and filtering support AV_PIX_FMT_D3D11 only."]
#[doc = ""]
#[doc = " data[0] contains a ID3D11Texture2D pointer, and data[1] contains the"]
#[doc = " texture array index of the frame as intptr_t if the ID3D11Texture2D is"]
#[doc = " an array texture (or always 0 if it's a normal texture)."]
pub const AVPixelFormat_AV_PIX_FMT_D3D11: AVPixelFormat = 172;
#[doc = "<        Y        , 9bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GRAY9BE: AVPixelFormat = 173;
#[doc = "<        Y        , 9bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GRAY9LE: AVPixelFormat = 174;
#[doc = "< IEEE-754 single precision planar GBR 4:4:4,     96bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRPF32BE: AVPixelFormat = 175;
#[doc = "< IEEE-754 single precision planar GBR 4:4:4,     96bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRPF32LE: AVPixelFormat = 176;
#[doc = "< IEEE-754 single precision planar GBRA 4:4:4:4, 128bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRAPF32BE: AVPixelFormat = 177;
#[doc = "< IEEE-754 single precision planar GBRA 4:4:4:4, 128bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GBRAPF32LE: AVPixelFormat = 178;
#[doc = " DRM-managed buffers exposed through PRIME buffer sharing."]
#[doc = ""]
#[doc = " data[0] points to an AVDRMFrameDescriptor."]
pub const AVPixelFormat_AV_PIX_FMT_DRM_PRIME: AVPixelFormat = 179;
#[doc = " Hardware surfaces for OpenCL."]
#[doc = ""]
#[doc = " data[i] contain 2D image objects (typed in C as cl_mem, used"]
#[doc = " in OpenCL as image2d_t) for each plane of the surface."]
pub const AVPixelFormat_AV_PIX_FMT_OPENCL: AVPixelFormat = 180;
#[doc = "<        Y        , 14bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GRAY14BE: AVPixelFormat = 181;
#[doc = "<        Y        , 14bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GRAY14LE: AVPixelFormat = 182;
#[doc = "< IEEE-754 single precision Y, 32bpp, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GRAYF32BE: AVPixelFormat = 183;
#[doc = "< IEEE-754 single precision Y, 32bpp, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_GRAYF32LE: AVPixelFormat = 184;
#[doc = "< planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), 12b alpha, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P12BE: AVPixelFormat = 185;
#[doc = "< planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), 12b alpha, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA422P12LE: AVPixelFormat = 186;
#[doc = "< planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), 12b alpha, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P12BE: AVPixelFormat = 187;
#[doc = "< planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), 12b alpha, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_YUVA444P12LE: AVPixelFormat = 188;
#[doc = "< planar YUV 4:4:4, 24bpp, 1 plane for Y and 1 plane for the UV components, which are interleaved (first byte U and the following byte V)"]
pub const AVPixelFormat_AV_PIX_FMT_NV24: AVPixelFormat = 189;
#[doc = "< as above, but U and V bytes are swapped"]
pub const AVPixelFormat_AV_PIX_FMT_NV42: AVPixelFormat = 190;
#[doc = " Vulkan hardware images."]
#[doc = ""]
#[doc = " data[0] points to an AVVkFrame"]
pub const AVPixelFormat_AV_PIX_FMT_VULKAN: AVPixelFormat = 191;
#[doc = "< packed YUV 4:2:2 like YUYV422, 20bpp, data in the high bits, big-endian"]
pub const AVPixelFormat_AV_PIX_FMT_Y210BE: AVPixelFormat = 192;
#[doc = "< packed YUV 4:2:2 like YUYV422, 20bpp, data in the high bits, little-endian"]
pub const AVPixelFormat_AV_PIX_FMT_Y210LE: AVPixelFormat = 193;
#[doc = "< packed RGB 10:10:10, 30bpp, (msb)2X 10R 10G 10B(lsb), little-endian, X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_X2RGB10LE: AVPixelFormat = 194;
#[doc = "< packed RGB 10:10:10, 30bpp, (msb)2X 10R 10G 10B(lsb), big-endian, X=unused/undefined"]
pub const AVPixelFormat_AV_PIX_FMT_X2RGB10BE: AVPixelFormat = 195;
#[doc = "< number of pixel formats, DO NOT USE THIS if you want to link with shared libav* because the number of formats might differ between versions"]
pub const AVPixelFormat_AV_PIX_FMT_NB: AVPixelFormat = 196;
#[doc = " Pixel format."]
#[doc = ""]
#[doc = " @note"]
#[doc = " AV_PIX_FMT_RGB32 is handled in an endian-specific manner. An RGBA"]
#[doc = " color is put together as:"]
#[doc = "  (A << 24) | (R << 16) | (G << 8) | B"]
#[doc = " This is stored as BGRA on little-endian CPU architectures and ARGB on"]
#[doc = " big-endian CPUs."]
#[doc = ""]
#[doc = " @note"]
#[doc = " If the resolution is not a multiple of the chroma subsampling factor"]
#[doc = " then the chroma plane resolution must be rounded up."]
#[doc = ""]
#[doc = " @par"]
#[doc = " When the pixel format is palettized RGB32 (AV_PIX_FMT_PAL8), the palettized"]
#[doc = " image data is stored in AVFrame.data[0]. The palette is transported in"]
#[doc = " AVFrame.data[1], is 1024 bytes long (256 4-byte entries) and is"]
#[doc = " formatted the same as in AV_PIX_FMT_RGB32 described above (i.e., it is"]
#[doc = " also endian-specific). Note also that the individual RGB32 palette"]
#[doc = " components stored in AVFrame.data[1] should be in the range 0..255."]
#[doc = " This is important as many custom PAL8 video codecs that were designed"]
#[doc = " to run on the IBM VGA graphics adapter use 6-bit palette components."]
#[doc = ""]
#[doc = " @par"]
#[doc = " For all the 8 bits per pixel formats, an RGB32 palette is in data[1] like"]
#[doc = " for pal8. This palette is filled in automatically by the function"]
#[doc = " allocating the picture."]
pub type AVPixelFormat = ::std::os::raw::c_int;
pub const AVColorPrimaries_AVCOL_PRI_RESERVED0: AVColorPrimaries = 0;
#[doc = "< also ITU-R BT1361 / IEC 61966-2-4 / SMPTE RP 177 Annex B"]
pub const AVColorPrimaries_AVCOL_PRI_BT709: AVColorPrimaries = 1;
pub const AVColorPrimaries_AVCOL_PRI_UNSPECIFIED: AVColorPrimaries = 2;
pub const AVColorPrimaries_AVCOL_PRI_RESERVED: AVColorPrimaries = 3;
#[doc = "< also FCC Title 47 Code of Federal Regulations 73.682 (a)(20)"]
pub const AVColorPrimaries_AVCOL_PRI_BT470M: AVColorPrimaries = 4;
#[doc = "< also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R BT1700 625 PAL & SECAM"]
pub const AVColorPrimaries_AVCOL_PRI_BT470BG: AVColorPrimaries = 5;
#[doc = "< also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC"]
pub const AVColorPrimaries_AVCOL_PRI_SMPTE170M: AVColorPrimaries = 6;
#[doc = "< identical to above, also called \"SMPTE C\" even though it uses D65"]
pub const AVColorPrimaries_AVCOL_PRI_SMPTE240M: AVColorPrimaries = 7;
#[doc = "< colour filters using Illuminant C"]
pub const AVColorPrimaries_AVCOL_PRI_FILM: AVColorPrimaries = 8;
#[doc = "< ITU-R BT2020"]
pub const AVColorPrimaries_AVCOL_PRI_BT2020: AVColorPrimaries = 9;
#[doc = "< SMPTE ST 428-1 (CIE 1931 XYZ)"]
pub const AVColorPrimaries_AVCOL_PRI_SMPTE428: AVColorPrimaries = 10;
pub const AVColorPrimaries_AVCOL_PRI_SMPTEST428_1: AVColorPrimaries = 10;
#[doc = "< SMPTE ST 431-2 (2011) / DCI P3"]
pub const AVColorPrimaries_AVCOL_PRI_SMPTE431: AVColorPrimaries = 11;
#[doc = "< SMPTE ST 432-1 (2010) / P3 D65 / Display P3"]
pub const AVColorPrimaries_AVCOL_PRI_SMPTE432: AVColorPrimaries = 12;
#[doc = "< EBU Tech. 3213-E (nothing there) / one of JEDEC P22 group phosphors"]
pub const AVColorPrimaries_AVCOL_PRI_EBU3213: AVColorPrimaries = 22;
pub const AVColorPrimaries_AVCOL_PRI_JEDEC_P22: AVColorPrimaries = 22;
#[doc = "< Not part of ABI"]
pub const AVColorPrimaries_AVCOL_PRI_NB: AVColorPrimaries = 23;
#[doc = " Chromaticity coordinates of the source primaries."]
#[doc = " These values match the ones defined by ISO/IEC 23091-2_2019 subclause 8.1 and ITU-T H.273."]
pub type AVColorPrimaries = ::std::os::raw::c_uint;
pub const AVColorTransferCharacteristic_AVCOL_TRC_RESERVED0: AVColorTransferCharacteristic = 0;
#[doc = "< also ITU-R BT1361"]
pub const AVColorTransferCharacteristic_AVCOL_TRC_BT709: AVColorTransferCharacteristic = 1;
pub const AVColorTransferCharacteristic_AVCOL_TRC_UNSPECIFIED: AVColorTransferCharacteristic = 2;
pub const AVColorTransferCharacteristic_AVCOL_TRC_RESERVED: AVColorTransferCharacteristic = 3;
#[doc = "< also ITU-R BT470M / ITU-R BT1700 625 PAL & SECAM"]
pub const AVColorTransferCharacteristic_AVCOL_TRC_GAMMA22: AVColorTransferCharacteristic = 4;
#[doc = "< also ITU-R BT470BG"]
pub const AVColorTransferCharacteristic_AVCOL_TRC_GAMMA28: AVColorTransferCharacteristic = 5;
#[doc = "< also ITU-R BT601-6 525 or 625 / ITU-R BT1358 525 or 625 / ITU-R BT1700 NTSC"]
pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTE170M: AVColorTransferCharacteristic = 6;
pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTE240M: AVColorTransferCharacteristic = 7;
#[doc = "< \"Linear transfer characteristics\""]
pub const AVColorTransferCharacteristic_AVCOL_TRC_LINEAR: AVColorTransferCharacteristic = 8;
#[doc = "< \"Logarithmic transfer characteristic (100:1 range)\""]
pub const AVColorTransferCharacteristic_AVCOL_TRC_LOG: AVColorTransferCharacteristic = 9;
#[doc = "< \"Logarithmic transfer characteristic (100 * Sqrt(10) : 1 range)\""]
pub const AVColorTransferCharacteristic_AVCOL_TRC_LOG_SQRT: AVColorTransferCharacteristic = 10;
#[doc = "< IEC 61966-2-4"]
pub const AVColorTransferCharacteristic_AVCOL_TRC_IEC61966_2_4: AVColorTransferCharacteristic = 11;
#[doc = "< ITU-R BT1361 Extended Colour Gamut"]
pub const AVColorTransferCharacteristic_AVCOL_TRC_BT1361_ECG: AVColorTransferCharacteristic = 12;
#[doc = "< IEC 61966-2-1 (sRGB or sYCC)"]
pub const AVColorTransferCharacteristic_AVCOL_TRC_IEC61966_2_1: AVColorTransferCharacteristic = 13;
#[doc = "< ITU-R BT2020 for 10-bit system"]
pub const AVColorTransferCharacteristic_AVCOL_TRC_BT2020_10: AVColorTransferCharacteristic = 14;
#[doc = "< ITU-R BT2020 for 12-bit system"]
pub const AVColorTransferCharacteristic_AVCOL_TRC_BT2020_12: AVColorTransferCharacteristic = 15;
#[doc = "< SMPTE ST 2084 for 10-, 12-, 14- and 16-bit systems"]
pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTE2084: AVColorTransferCharacteristic = 16;
pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTEST2084: AVColorTransferCharacteristic = 16;
#[doc = "< SMPTE ST 428-1"]
pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTE428: AVColorTransferCharacteristic = 17;
pub const AVColorTransferCharacteristic_AVCOL_TRC_SMPTEST428_1: AVColorTransferCharacteristic = 17;
#[doc = "< ARIB STD-B67, known as \"Hybrid log-gamma\""]
pub const AVColorTransferCharacteristic_AVCOL_TRC_ARIB_STD_B67: AVColorTransferCharacteristic = 18;
#[doc = "< Not part of ABI"]
pub const AVColorTransferCharacteristic_AVCOL_TRC_NB: AVColorTransferCharacteristic = 19;
#[doc = " Color Transfer Characteristic."]
#[doc = " These values match the ones defined by ISO/IEC 23091-2_2019 subclause 8.2."]
pub type AVColorTransferCharacteristic = ::std::os::raw::c_uint;
#[doc = "< order of coefficients is actually GBR, also IEC 61966-2-1 (sRGB), YZX and ST 428-1"]
pub const AVColorSpace_AVCOL_SPC_RGB: AVColorSpace = 0;
#[doc = "< also ITU-R BT1361 / IEC 61966-2-4 xvYCC709 / derived in SMPTE RP 177 Annex B"]
pub const AVColorSpace_AVCOL_SPC_BT709: AVColorSpace = 1;
pub const AVColorSpace_AVCOL_SPC_UNSPECIFIED: AVColorSpace = 2;
#[doc = "< reserved for future use by ITU-T and ISO/IEC just like 15-255 are"]
pub const AVColorSpace_AVCOL_SPC_RESERVED: AVColorSpace = 3;
#[doc = "< FCC Title 47 Code of Federal Regulations 73.682 (a)(20)"]
pub const AVColorSpace_AVCOL_SPC_FCC: AVColorSpace = 4;
#[doc = "< also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R BT1700 625 PAL & SECAM / IEC 61966-2-4 xvYCC601"]
pub const AVColorSpace_AVCOL_SPC_BT470BG: AVColorSpace = 5;
#[doc = "< also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC / functionally identical to above"]
pub const AVColorSpace_AVCOL_SPC_SMPTE170M: AVColorSpace = 6;
#[doc = "< derived from 170M primaries and D65 white point, 170M is derived from BT470 System M's primaries"]
pub const AVColorSpace_AVCOL_SPC_SMPTE240M: AVColorSpace = 7;
#[doc = "< used by Dirac / VC-2 and H.264 FRext, see ITU-T SG16"]
pub const AVColorSpace_AVCOL_SPC_YCGCO: AVColorSpace = 8;
pub const AVColorSpace_AVCOL_SPC_YCOCG: AVColorSpace = 8;
#[doc = "< ITU-R BT2020 non-constant luminance system"]
pub const AVColorSpace_AVCOL_SPC_BT2020_NCL: AVColorSpace = 9;
#[doc = "< ITU-R BT2020 constant luminance system"]
pub const AVColorSpace_AVCOL_SPC_BT2020_CL: AVColorSpace = 10;
#[doc = "< SMPTE 2085, Y'D'zD'x"]
pub const AVColorSpace_AVCOL_SPC_SMPTE2085: AVColorSpace = 11;
#[doc = "< Chromaticity-derived non-constant luminance system"]
pub const AVColorSpace_AVCOL_SPC_CHROMA_DERIVED_NCL: AVColorSpace = 12;
#[doc = "< Chromaticity-derived constant luminance system"]
pub const AVColorSpace_AVCOL_SPC_CHROMA_DERIVED_CL: AVColorSpace = 13;
#[doc = "< ITU-R BT.2100-0, ICtCp"]
pub const AVColorSpace_AVCOL_SPC_ICTCP: AVColorSpace = 14;
#[doc = "< Not part of ABI"]
pub const AVColorSpace_AVCOL_SPC_NB: AVColorSpace = 15;
#[doc = " YUV colorspace type."]
#[doc = " These values match the ones defined by ISO/IEC 23091-2_2019 subclause 8.3."]
pub type AVColorSpace = ::std::os::raw::c_uint;
pub const AVColorRange_AVCOL_RANGE_UNSPECIFIED: AVColorRange = 0;
#[doc = " Narrow or limited range content."]
#[doc = ""]
#[doc = " - For luma planes:"]
#[doc = ""]
#[doc = "       (219 * E + 16) * 2^(n-8)"]
#[doc = ""]
#[doc = "   F.ex. the range of 16-235 for 8 bits"]
#[doc = ""]
#[doc = " - For chroma planes:"]
#[doc = ""]
#[doc = "       (224 * E + 128) * 2^(n-8)"]
#[doc = ""]
#[doc = "   F.ex. the range of 16-240 for 8 bits"]
pub const AVColorRange_AVCOL_RANGE_MPEG: AVColorRange = 1;
#[doc = " Full range content."]
#[doc = ""]
#[doc = " - For RGB and luma planes:"]
#[doc = ""]
#[doc = "       (2^n - 1) * E"]
#[doc = ""]
#[doc = "   F.ex. the range of 0-255 for 8 bits"]
#[doc = ""]
#[doc = " - For chroma planes:"]
#[doc = ""]
#[doc = "       (2^n - 1) * E + 2^(n - 1)"]
#[doc = ""]
#[doc = "   F.ex. the range of 1-255 for 8 bits"]
pub const AVColorRange_AVCOL_RANGE_JPEG: AVColorRange = 2;
#[doc = "< Not part of ABI"]
pub const AVColorRange_AVCOL_RANGE_NB: AVColorRange = 3;
#[doc = " Visual content value range."]
#[doc = ""]
#[doc = " These values are based on definitions that can be found in multiple"]
#[doc = " specifications, such as ITU-T BT.709 (3.4 - Quantization of RGB, luminance"]
#[doc = " and colour-difference signals), ITU-T BT.2020 (Table 5 - Digital"]
#[doc = " Representation) as well as ITU-T BT.2100 (Table 9 - Digital 10- and 12-bit"]
#[doc = " integer representation). At the time of writing, the BT.2100 one is"]
#[doc = " recommended, as it also defines the full range representation."]
#[doc = ""]
#[doc = " Common definitions:"]
#[doc = "   - For RGB and luma planes such as Y in YCbCr and I in ICtCp,"]
#[doc = "     'E' is the original value in range of 0.0 to 1.0."]
#[doc = "   - For chroma planes such as Cb,Cr and Ct,Cp, 'E' is the original"]
#[doc = "     value in range of -0.5 to 0.5."]
#[doc = "   - 'n' is the output bit depth."]
#[doc = "   - For additional definitions such as rounding and clipping to valid n"]
#[doc = "     bit unsigned integer range, please refer to BT.2100 (Table 9)."]
pub type AVColorRange = ::std::os::raw::c_uint;
pub const AVChromaLocation_AVCHROMA_LOC_UNSPECIFIED: AVChromaLocation = 0;
#[doc = "< MPEG-2/4 4:2:0, H.264 default for 4:2:0"]
pub const AVChromaLocation_AVCHROMA_LOC_LEFT: AVChromaLocation = 1;
#[doc = "< MPEG-1 4:2:0, JPEG 4:2:0, H.263 4:2:0"]
pub const AVChromaLocation_AVCHROMA_LOC_CENTER: AVChromaLocation = 2;
#[doc = "< ITU-R 601, SMPTE 274M 296M S314M(DV 4:1:1), mpeg2 4:2:2"]
pub const AVChromaLocation_AVCHROMA_LOC_TOPLEFT: AVChromaLocation = 3;
pub const AVChromaLocation_AVCHROMA_LOC_TOP: AVChromaLocation = 4;
pub const AVChromaLocation_AVCHROMA_LOC_BOTTOMLEFT: AVChromaLocation = 5;
pub const AVChromaLocation_AVCHROMA_LOC_BOTTOM: AVChromaLocation = 6;
#[doc = "< Not part of ABI"]
pub const AVChromaLocation_AVCHROMA_LOC_NB: AVChromaLocation = 7;
#[doc = " Location of chroma samples."]
#[doc = ""]
#[doc = " Illustration showing the location of the first (top left) chroma sample of the"]
#[doc = " image, the left shows only luma, the right"]
#[doc = " shows the location of the chroma sample, the 2 could be imagined to overlay"]
#[doc = " each other but are drawn separately due to limitations of ASCII"]
#[doc = ""]
#[doc = "                1st 2nd       1st 2nd horizontal luma sample positions"]
#[doc = "                 v   v         v   v"]
#[doc = "                 ______        ______"]
#[doc = "1st luma line > |X   X ...    |3 4 X ...     X are luma samples,"]
#[doc = "                |             |1 2           1-6 are possible chroma positions"]
#[doc = "2nd luma line > |X   X ...    |5 6 X ...     0 is undefined/unknown position"]
pub type AVChromaLocation = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct AVComponentDescriptor {
    #[doc = " Which of the 4 planes contains the component."]
    pub plane: ::std::os::raw::c_int,
    #[doc = " Number of elements between 2 horizontally consecutive pixels."]
    #[doc = " Elements are bits for bitstream formats, bytes otherwise."]
    pub step: ::std::os::raw::c_int,
    #[doc = " Number of elements before the component of the first pixel."]
    #[doc = " Elements are bits for bitstream formats, bytes otherwise."]
    pub offset: ::std::os::raw::c_int,
    #[doc = " Number of least significant bits that must be shifted away"]
    #[doc = " to get the value."]
    pub shift: ::std::os::raw::c_int,
    #[doc = " Number of bits in the component."]
    pub depth: ::std::os::raw::c_int,
}
#[doc = " Descriptor that unambiguously describes how the bits of a pixel are"]
#[doc = " stored in the up to 4 data planes of an image. It also stores the"]
#[doc = " subsampling factors and number of components."]
#[doc = ""]
#[doc = " @note This is separate of the colorspace (RGB, YCbCr, YPbPr, JPEG-style YUV"]
#[doc = "       and all the YUV variants) AVPixFmtDescriptor just stores how values"]
#[doc = "       are stored not what these values represent."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct AVPixFmtDescriptor {
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< The number of components each pixel has, (1-4)"]
    pub nb_components: u8,
    #[doc = " Amount to shift the luma width right to find the chroma width."]
    #[doc = " For YV12 this is 1 for example."]
    #[doc = " chroma_width = AV_CEIL_RSHIFT(luma_width, log2_chroma_w)"]
    #[doc = " The note above is needed to ensure rounding up."]
    #[doc = " This value only refers to the chroma components."]
    pub log2_chroma_w: u8,
    #[doc = " Amount to shift the luma height right to find the chroma height."]
    #[doc = " For YV12 this is 1 for example."]
    #[doc = " chroma_height= AV_CEIL_RSHIFT(luma_height, log2_chroma_h)"]
    #[doc = " The note above is needed to ensure rounding up."]
    #[doc = " This value only refers to the chroma components."]
    pub log2_chroma_h: u8,
    #[doc = " Combination of AV_PIX_FMT_FLAG_... flags."]
    pub flags: u64,
    #[doc = " Parameters that describe how pixels are packed."]
    #[doc = " If the format has 1 or 2 components, then luma is 0."]
    #[doc = " If the format has 3 or 4 components:"]
    #[doc = "   if the RGB flag is set then 0 is red, 1 is green and 2 is blue;"]
    #[doc = "   otherwise 0 is luma, 1 is chroma-U and 2 is chroma-V."]
    #[doc = ""]
    #[doc = " If present, the Alpha channel is always the last component."]
    pub comp: [AVComponentDescriptor; 4usize],
    #[doc = " Alternative comma-separated names."]
    pub alias: *const ::std::os::raw::c_char,
}
impl Default for AVPixFmtDescriptor {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Return the number of bits per pixel used by the pixel format"]
    #[doc = " described by pixdesc. Note that this is not the same as the number"]
    #[doc = " of bits per sample."]
    #[doc = ""]
    #[doc = " The returned number of bits refers to the number of bits actually"]
    #[doc = " used for storing the pixel information, that is padding bits are"]
    #[doc = " not counted."]
    pub fn av_get_bits_per_pixel(pixdesc: *const AVPixFmtDescriptor) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the number of bits per pixel for the pixel format"]
    #[doc = " described by pixdesc, including any padding or unused bits."]
    pub fn av_get_padded_bits_per_pixel(
        pixdesc: *const AVPixFmtDescriptor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return a pixel format descriptor for provided pixel format or NULL if"]
    #[doc = " this pixel format is unknown."]
    pub fn av_pix_fmt_desc_get(pix_fmt: AVPixelFormat) -> *const AVPixFmtDescriptor;
}
extern "C" {
    #[doc = " Iterate over all pixel format descriptors known to libavutil."]
    #[doc = ""]
    #[doc = " @param prev previous descriptor. NULL to get the first descriptor."]
    #[doc = ""]
    #[doc = " @return next descriptor or NULL after the last descriptor"]
    pub fn av_pix_fmt_desc_next(prev: *const AVPixFmtDescriptor) -> *const AVPixFmtDescriptor;
}
extern "C" {
    #[doc = " @return an AVPixelFormat id described by desc, or AV_PIX_FMT_NONE if desc"]
    #[doc = " is not a valid pointer to a pixel format descriptor."]
    pub fn av_pix_fmt_desc_get_id(desc: *const AVPixFmtDescriptor) -> AVPixelFormat;
}
extern "C" {
    #[doc = " Utility function to access log2_chroma_w log2_chroma_h from"]
    #[doc = " the pixel format AVPixFmtDescriptor."]
    #[doc = ""]
    #[doc = " @param[in]  pix_fmt the pixel format"]
    #[doc = " @param[out] h_shift store log2_chroma_w (horizontal/width shift)"]
    #[doc = " @param[out] v_shift store log2_chroma_h (vertical/height shift)"]
    #[doc = ""]
    #[doc = " @return 0 on success, AVERROR(ENOSYS) on invalid or unknown pixel format"]
    pub fn av_pix_fmt_get_chroma_sub_sample(
        pix_fmt: AVPixelFormat,
        h_shift: *mut ::std::os::raw::c_int,
        v_shift: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return number of planes in pix_fmt, a negative AVERROR if pix_fmt is not a"]
    #[doc = " valid pixel format."]
    pub fn av_pix_fmt_count_planes(pix_fmt: AVPixelFormat) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return the name for provided color range or NULL if unknown."]
    pub fn av_color_range_name(range: AVColorRange) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @return the AVColorRange value for name or an AVError if not found."]
    pub fn av_color_range_from_name(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return the name for provided color primaries or NULL if unknown."]
    pub fn av_color_primaries_name(primaries: AVColorPrimaries) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @return the AVColorPrimaries value for name or an AVError if not found."]
    pub fn av_color_primaries_from_name(
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return the name for provided color transfer or NULL if unknown."]
    pub fn av_color_transfer_name(
        transfer: AVColorTransferCharacteristic,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @return the AVColorTransferCharacteristic value for name or an AVError if not found."]
    pub fn av_color_transfer_from_name(
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return the name for provided color space or NULL if unknown."]
    pub fn av_color_space_name(space: AVColorSpace) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @return the AVColorSpace value for name or an AVError if not found."]
    pub fn av_color_space_from_name(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @return the name for provided chroma location or NULL if unknown."]
    pub fn av_chroma_location_name(location: AVChromaLocation) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @return the AVChromaLocation value for name or an AVError if not found."]
    pub fn av_chroma_location_from_name(
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the pixel format corresponding to name."]
    #[doc = ""]
    #[doc = " If there is no pixel format with name name, then looks for a"]
    #[doc = " pixel format with the name corresponding to the native endian"]
    #[doc = " format of name."]
    #[doc = " For example in a little-endian system, first looks for \"gray16\","]
    #[doc = " then for \"gray16le\"."]
    #[doc = ""]
    #[doc = " Finally if no pixel format has been found, returns AV_PIX_FMT_NONE."]
    pub fn av_get_pix_fmt(name: *const ::std::os::raw::c_char) -> AVPixelFormat;
}
extern "C" {
    #[doc = " Return the short name for a pixel format, NULL in case pix_fmt is"]
    #[doc = " unknown."]
    #[doc = ""]
    #[doc = " @see av_get_pix_fmt(), av_get_pix_fmt_string()"]
    pub fn av_get_pix_fmt_name(pix_fmt: AVPixelFormat) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Print in buf the string corresponding to the pixel format with"]
    #[doc = " number pix_fmt, or a header if pix_fmt is negative."]
    #[doc = ""]
    #[doc = " @param buf the buffer where to write the string"]
    #[doc = " @param buf_size the size of buf"]
    #[doc = " @param pix_fmt the number of the pixel format to print the"]
    #[doc = " corresponding info string, or a negative value to print the"]
    #[doc = " corresponding header."]
    pub fn av_get_pix_fmt_string(
        buf: *mut ::std::os::raw::c_char,
        buf_size: ::std::os::raw::c_int,
        pix_fmt: AVPixelFormat,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Read a line from an image, and write the values of the"]
    #[doc = " pixel format component c to dst."]
    #[doc = ""]
    #[doc = " @param data the array containing the pointers to the planes of the image"]
    #[doc = " @param linesize the array containing the linesizes of the image"]
    #[doc = " @param desc the pixel format descriptor for the image"]
    #[doc = " @param x the horizontal coordinate of the first pixel to read"]
    #[doc = " @param y the vertical coordinate of the first pixel to read"]
    #[doc = " @param w the width of the line to read, that is the number of"]
    #[doc = " values to write to dst"]
    #[doc = " @param read_pal_component if not zero and the format is a paletted"]
    #[doc = " format writes the values corresponding to the palette"]
    #[doc = " component c in data[1] to dst, rather than the palette indexes in"]
    #[doc = " data[0]. The behavior is undefined if the format is not paletted."]
    #[doc = " @param dst_element_size size of elements in dst array (2 or 4 byte)"]
    pub fn av_read_image_line2(
        dst: *mut ::std::os::raw::c_void,
        data: *mut *const u8,
        linesize: *const ::std::os::raw::c_int,
        desc: *const AVPixFmtDescriptor,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        c: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        read_pal_component: ::std::os::raw::c_int,
        dst_element_size: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn av_read_image_line(
        dst: *mut u16,
        data: *mut *const u8,
        linesize: *const ::std::os::raw::c_int,
        desc: *const AVPixFmtDescriptor,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        c: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        read_pal_component: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Write the values from src to the pixel format component c of an"]
    #[doc = " image line."]
    #[doc = ""]
    #[doc = " @param src array containing the values to write"]
    #[doc = " @param data the array containing the pointers to the planes of the"]
    #[doc = " image to write into. It is supposed to be zeroed."]
    #[doc = " @param linesize the array containing the linesizes of the image"]
    #[doc = " @param desc the pixel format descriptor for the image"]
    #[doc = " @param x the horizontal coordinate of the first pixel to write"]
    #[doc = " @param y the vertical coordinate of the first pixel to write"]
    #[doc = " @param w the width of the line to write, that is the number of"]
    #[doc = " values to write to the image line"]
    #[doc = " @param src_element_size size of elements in src array (2 or 4 byte)"]
    pub fn av_write_image_line2(
        src: *const ::std::os::raw::c_void,
        data: *mut *mut u8,
        linesize: *const ::std::os::raw::c_int,
        desc: *const AVPixFmtDescriptor,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        c: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
        src_element_size: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn av_write_image_line(
        src: *const u16,
        data: *mut *mut u8,
        linesize: *const ::std::os::raw::c_int,
        desc: *const AVPixFmtDescriptor,
        x: ::std::os::raw::c_int,
        y: ::std::os::raw::c_int,
        c: ::std::os::raw::c_int,
        w: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " Utility function to swap the endianness of a pixel format."]
    #[doc = ""]
    #[doc = " @param[in]  pix_fmt the pixel format"]
    #[doc = ""]
    #[doc = " @return pixel format with swapped endianness if it exists,"]
    #[doc = " otherwise AV_PIX_FMT_NONE"]
    pub fn av_pix_fmt_swap_endianness(pix_fmt: AVPixelFormat) -> AVPixelFormat;
}
extern "C" {
    #[doc = " Compute what kind of losses will occur when converting from one specific"]
    #[doc = " pixel format to another."]
    #[doc = " When converting from one pixel format to another, information loss may occur."]
    #[doc = " For example, when converting from RGB24 to GRAY, the color information will"]
    #[doc = " be lost. Similarly, other losses occur when converting from some formats to"]
    #[doc = " other formats. These losses can involve loss of chroma, but also loss of"]
    #[doc = " resolution, loss of color depth, loss due to the color space conversion, loss"]
    #[doc = " of the alpha bits or loss due to color quantization."]
    #[doc = " av_get_fix_fmt_loss() informs you about the various types of losses"]
    #[doc = " which will occur when converting from one pixel format to another."]
    #[doc = ""]
    #[doc = " @param[in] dst_pix_fmt destination pixel format"]
    #[doc = " @param[in] src_pix_fmt source pixel format"]
    #[doc = " @param[in] has_alpha Whether the source pixel format alpha channel is used."]
    #[doc = " @return Combination of flags informing you what kind of losses will occur"]
    #[doc = " (maximum loss for an invalid dst_pix_fmt)."]
    pub fn av_get_pix_fmt_loss(
        dst_pix_fmt: AVPixelFormat,
        src_pix_fmt: AVPixelFormat,
        has_alpha: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Compute what kind of losses will occur when converting from one specific"]
    #[doc = " pixel format to another."]
    #[doc = " When converting from one pixel format to another, information loss may occur."]
    #[doc = " For example, when converting from RGB24 to GRAY, the color information will"]
    #[doc = " be lost. Similarly, other losses occur when converting from some formats to"]
    #[doc = " other formats. These losses can involve loss of chroma, but also loss of"]
    #[doc = " resolution, loss of color depth, loss due to the color space conversion, loss"]
    #[doc = " of the alpha bits or loss due to color quantization."]
    #[doc = " av_get_fix_fmt_loss() informs you about the various types of losses"]
    #[doc = " which will occur when converting from one pixel format to another."]
    #[doc = ""]
    #[doc = " @param[in] dst_pix_fmt destination pixel format"]
    #[doc = " @param[in] src_pix_fmt source pixel format"]
    #[doc = " @param[in] has_alpha Whether the source pixel format alpha channel is used."]
    #[doc = " @return Combination of flags informing you what kind of losses will occur"]
    #[doc = " (maximum loss for an invalid dst_pix_fmt)."]
    pub fn av_find_best_pix_fmt_of_2(
        dst_pix_fmt1: AVPixelFormat,
        dst_pix_fmt2: AVPixelFormat,
        src_pix_fmt: AVPixelFormat,
        has_alpha: ::std::os::raw::c_int,
        loss_ptr: *mut ::std::os::raw::c_int,
    ) -> AVPixelFormat;
}
